// Code generated by rpcmetagen. DO NOT EDIT.
// Copyright (c) 2020 Arista Networks, Inc.  All rights reserved.
// Arista Networks, Inc. Confidential and Proprietary.
// Subject to Arista Networks, Inc.'s EULA.
// FOR INTERNAL USE ONLY. NOT FOR DISTRIBUTION.

package clouddeploy_v1

import (
	"fmt"
	"strings"

	// include utils for casing of field masks
	"cloudeos-terraform-provider/resources/protobuf"

	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

//
// AwsRouterDetail
//

// AwsRouterDetailFieldFilter works as a type-safety guarantee for updates vs. filters
type AwsRouterDetailFieldFilter func(target *AwsRouterDetail) error

// NewAwsRouterDetailFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewAwsRouterDetailFilter(
	fns ...AwsRouterDetailFieldFilter,
) (*AwsRouterDetail, error) {
	result := &AwsRouterDetail{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing AwsRouterDetail.
func (m *AwsRouterDetail) AddFilters(fns ...AwsRouterDetailFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// AwsRouterDetailFieldUpdate works as a type-safety guarantee for updates vs. filters
type AwsRouterDetailFieldUpdate func(target *AwsRouterDetail) error

// NewAwsRouterDetailUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewAwsRouterDetailUpdate(
	fns ...AwsRouterDetailFieldUpdate,
) (*AwsRouterDetail, error) {
	result := &AwsRouterDetail{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing AwsRouterDetail.
func (m *AwsRouterDetail) AddUpdates(fns ...AwsRouterDetailFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *AwsRouterDetail) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *AwsRouterDetail) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this AwsRouterDetail
func (m *AwsRouterDetail) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"availZone",
			"instanceType",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AwsRouterDetail) addAvailZone(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"availZone",
	)

	m.AvailZone = val
	return nil
}

// FilterAwsRouterDetailAvailZone exists only for type-safety.
// All work is done in addAvailZone(...)
func FilterAwsRouterDetailAvailZone(val string) AwsRouterDetailFieldFilter {
	return func(tgt *AwsRouterDetail) error {
		return tgt.addAvailZone(val)
	}
}

// AvailZoneWasSet allows for checking if AvailZone is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsRouterDetail) AvailZoneWasSet() (bool, bool) {
	prefix := "availZone."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AvailZoneIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsRouterDetail) AvailZoneIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsRouterDetail) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsRouterDetail) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AwsRouterDetail) addInstanceType(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"instanceType",
	)

	m.InstanceType = val
	return nil
}

// FilterAwsRouterDetailInstanceType exists only for type-safety.
// All work is done in addInstanceType(...)
func FilterAwsRouterDetailInstanceType(val string) AwsRouterDetailFieldFilter {
	return func(tgt *AwsRouterDetail) error {
		return tgt.addInstanceType(val)
	}
}

// InstanceTypeWasSet allows for checking if InstanceType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsRouterDetail) InstanceTypeWasSet() (bool, bool) {
	prefix := "instanceType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// InstanceTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsRouterDetail) InstanceTypeIsModifiable() bool {
	return false
}

//
// AwsVpcInfo
//

// AwsVpcInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type AwsVpcInfoFieldFilter func(target *AwsVpcInfo) error

// NewAwsVpcInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewAwsVpcInfoFilter(
	fns ...AwsVpcInfoFieldFilter,
) (*AwsVpcInfo, error) {
	result := &AwsVpcInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing AwsVpcInfo.
func (m *AwsVpcInfo) AddFilters(fns ...AwsVpcInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// AwsVpcInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type AwsVpcInfoFieldUpdate func(target *AwsVpcInfo) error

// NewAwsVpcInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewAwsVpcInfoUpdate(
	fns ...AwsVpcInfoFieldUpdate,
) (*AwsVpcInfo, error) {
	result := &AwsVpcInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing AwsVpcInfo.
func (m *AwsVpcInfo) AddUpdates(fns ...AwsVpcInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *AwsVpcInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *AwsVpcInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this AwsVpcInfo
func (m *AwsVpcInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"cidr",
			"igwId",
			"peeringConnId",
			"securityGroup",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AwsVpcInfo) addCidr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cidr",
	)

	m.Cidr = val
	return nil
}

// FilterAwsVpcInfoCidr exists only for type-safety.
// All work is done in addCidr(...)
func FilterAwsVpcInfoCidr(val string) AwsVpcInfoFieldFilter {
	return func(tgt *AwsVpcInfo) error {
		return tgt.addCidr(val)
	}
}

// CidrWasSet allows for checking if Cidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsVpcInfo) CidrWasSet() (bool, bool) {
	prefix := "cidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CidrIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsVpcInfo) CidrIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsVpcInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsVpcInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AwsVpcInfo) addIgwId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"igwId",
	)

	m.IgwId = val
	return nil
}

// FilterAwsVpcInfoIgwId exists only for type-safety.
// All work is done in addIgwId(...)
func FilterAwsVpcInfoIgwId(val string) AwsVpcInfoFieldFilter {
	return func(tgt *AwsVpcInfo) error {
		return tgt.addIgwId(val)
	}
}

// IgwIdWasSet allows for checking if IgwId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsVpcInfo) IgwIdWasSet() (bool, bool) {
	prefix := "igwId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IgwIdIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsVpcInfo) IgwIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AwsVpcInfo) addPeeringConnId(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peeringConnId",
	)

	m.PeeringConnId = val
	return nil
}

// FilterAwsVpcInfoPeeringConnId exists only for type-safety.
// All work is done in addPeeringConnId(...)
func FilterAwsVpcInfoPeeringConnId(val []string) AwsVpcInfoFieldFilter {
	return func(tgt *AwsVpcInfo) error {
		return tgt.addPeeringConnId(val)
	}
}

// PeeringConnIdWasSet allows for checking if PeeringConnId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsVpcInfo) PeeringConnIdWasSet() (bool, bool) {
	prefix := "peeringConnId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeeringConnIdIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsVpcInfo) PeeringConnIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AwsVpcInfo) addSecurityGroup(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"securityGroup",
	)

	m.SecurityGroup = val
	return nil
}

// FilterAwsVpcInfoSecurityGroup exists only for type-safety.
// All work is done in addSecurityGroup(...)
func FilterAwsVpcInfoSecurityGroup(val []string) AwsVpcInfoFieldFilter {
	return func(tgt *AwsVpcInfo) error {
		return tgt.addSecurityGroup(val)
	}
}

// SecurityGroupWasSet allows for checking if SecurityGroup is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AwsVpcInfo) SecurityGroupWasSet() (bool, bool) {
	prefix := "securityGroup."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SecurityGroupIsModifiable defines whether this field is modifiable per the specs.
func (m *AwsVpcInfo) SecurityGroupIsModifiable() bool {
	return false
}

//
// AzureRouterDetail
//

// AzureRouterDetailFieldFilter works as a type-safety guarantee for updates vs. filters
type AzureRouterDetailFieldFilter func(target *AzureRouterDetail) error

// NewAzureRouterDetailFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewAzureRouterDetailFilter(
	fns ...AzureRouterDetailFieldFilter,
) (*AzureRouterDetail, error) {
	result := &AzureRouterDetail{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing AzureRouterDetail.
func (m *AzureRouterDetail) AddFilters(fns ...AzureRouterDetailFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureRouterDetailFieldUpdate works as a type-safety guarantee for updates vs. filters
type AzureRouterDetailFieldUpdate func(target *AzureRouterDetail) error

// NewAzureRouterDetailUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewAzureRouterDetailUpdate(
	fns ...AzureRouterDetailFieldUpdate,
) (*AzureRouterDetail, error) {
	result := &AzureRouterDetail{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing AzureRouterDetail.
func (m *AzureRouterDetail) AddUpdates(fns ...AzureRouterDetailFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *AzureRouterDetail) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *AzureRouterDetail) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this AzureRouterDetail
func (m *AzureRouterDetail) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"availSet",
			"availZone",
			"instanceType",
			"resGroup",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureRouterDetail) addAvailSet(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"availSet",
	)

	m.AvailSet = val
	return nil
}

// FilterAzureRouterDetailAvailSet exists only for type-safety.
// All work is done in addAvailSet(...)
func FilterAzureRouterDetailAvailSet(val string) AzureRouterDetailFieldFilter {
	return func(tgt *AzureRouterDetail) error {
		return tgt.addAvailSet(val)
	}
}

// AvailSetWasSet allows for checking if AvailSet is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureRouterDetail) AvailSetWasSet() (bool, bool) {
	prefix := "availSet."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AvailSetIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureRouterDetail) AvailSetIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureRouterDetail) addAvailZone(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"availZone",
	)

	m.AvailZone = val
	return nil
}

// FilterAzureRouterDetailAvailZone exists only for type-safety.
// All work is done in addAvailZone(...)
func FilterAzureRouterDetailAvailZone(val string) AzureRouterDetailFieldFilter {
	return func(tgt *AzureRouterDetail) error {
		return tgt.addAvailZone(val)
	}
}

// AvailZoneWasSet allows for checking if AvailZone is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureRouterDetail) AvailZoneWasSet() (bool, bool) {
	prefix := "availZone."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AvailZoneIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureRouterDetail) AvailZoneIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureRouterDetail) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureRouterDetail) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureRouterDetail) addInstanceType(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"instanceType",
	)

	m.InstanceType = val
	return nil
}

// FilterAzureRouterDetailInstanceType exists only for type-safety.
// All work is done in addInstanceType(...)
func FilterAzureRouterDetailInstanceType(val string) AzureRouterDetailFieldFilter {
	return func(tgt *AzureRouterDetail) error {
		return tgt.addInstanceType(val)
	}
}

// InstanceTypeWasSet allows for checking if InstanceType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureRouterDetail) InstanceTypeWasSet() (bool, bool) {
	prefix := "instanceType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// InstanceTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureRouterDetail) InstanceTypeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureRouterDetail) addResGroup(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"resGroup",
	)

	m.ResGroup = val
	return nil
}

// FilterAzureRouterDetailResGroup exists only for type-safety.
// All work is done in addResGroup(...)
func FilterAzureRouterDetailResGroup(val string) AzureRouterDetailFieldFilter {
	return func(tgt *AzureRouterDetail) error {
		return tgt.addResGroup(val)
	}
}

// ResGroupWasSet allows for checking if ResGroup is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureRouterDetail) ResGroupWasSet() (bool, bool) {
	prefix := "resGroup."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// ResGroupIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureRouterDetail) ResGroupIsModifiable() bool {
	return false
}

//
// AzureVnetInfo
//

// AzureVnetInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type AzureVnetInfoFieldFilter func(target *AzureVnetInfo) error

// NewAzureVnetInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewAzureVnetInfoFilter(
	fns ...AzureVnetInfoFieldFilter,
) (*AzureVnetInfo, error) {
	result := &AzureVnetInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing AzureVnetInfo.
func (m *AzureVnetInfo) AddFilters(fns ...AzureVnetInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// AzureVnetInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type AzureVnetInfoFieldUpdate func(target *AzureVnetInfo) error

// NewAzureVnetInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewAzureVnetInfoUpdate(
	fns ...AzureVnetInfoFieldUpdate,
) (*AzureVnetInfo, error) {
	result := &AzureVnetInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing AzureVnetInfo.
func (m *AzureVnetInfo) AddUpdates(fns ...AzureVnetInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *AzureVnetInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *AzureVnetInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this AzureVnetInfo
func (m *AzureVnetInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"availSet",
			"cidr",
			"nsg",
			"peeringConnId",
			"resourceGroup",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureVnetInfo) addAvailSet(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"availSet",
	)

	m.AvailSet = val
	return nil
}

// FilterAzureVnetInfoAvailSet exists only for type-safety.
// All work is done in addAvailSet(...)
func FilterAzureVnetInfoAvailSet(val []string) AzureVnetInfoFieldFilter {
	return func(tgt *AzureVnetInfo) error {
		return tgt.addAvailSet(val)
	}
}

// AvailSetWasSet allows for checking if AvailSet is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureVnetInfo) AvailSetWasSet() (bool, bool) {
	prefix := "availSet."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AvailSetIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureVnetInfo) AvailSetIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureVnetInfo) addCidr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cidr",
	)

	m.Cidr = val
	return nil
}

// FilterAzureVnetInfoCidr exists only for type-safety.
// All work is done in addCidr(...)
func FilterAzureVnetInfoCidr(val string) AzureVnetInfoFieldFilter {
	return func(tgt *AzureVnetInfo) error {
		return tgt.addCidr(val)
	}
}

// CidrWasSet allows for checking if Cidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureVnetInfo) CidrWasSet() (bool, bool) {
	prefix := "cidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CidrIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureVnetInfo) CidrIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureVnetInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureVnetInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureVnetInfo) addNsg(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"nsg",
	)

	m.Nsg = val
	return nil
}

// FilterAzureVnetInfoNsg exists only for type-safety.
// All work is done in addNsg(...)
func FilterAzureVnetInfoNsg(val []string) AzureVnetInfoFieldFilter {
	return func(tgt *AzureVnetInfo) error {
		return tgt.addNsg(val)
	}
}

// NsgWasSet allows for checking if Nsg is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureVnetInfo) NsgWasSet() (bool, bool) {
	prefix := "nsg."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// NsgIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureVnetInfo) NsgIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureVnetInfo) addPeeringConnId(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peeringConnId",
	)

	m.PeeringConnId = val
	return nil
}

// FilterAzureVnetInfoPeeringConnId exists only for type-safety.
// All work is done in addPeeringConnId(...)
func FilterAzureVnetInfoPeeringConnId(val []string) AzureVnetInfoFieldFilter {
	return func(tgt *AzureVnetInfo) error {
		return tgt.addPeeringConnId(val)
	}
}

// PeeringConnIdWasSet allows for checking if PeeringConnId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureVnetInfo) PeeringConnIdWasSet() (bool, bool) {
	prefix := "peeringConnId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeeringConnIdIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureVnetInfo) PeeringConnIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *AzureVnetInfo) addResourceGroup(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"resourceGroup",
	)

	m.ResourceGroup = val
	return nil
}

// FilterAzureVnetInfoResourceGroup exists only for type-safety.
// All work is done in addResourceGroup(...)
func FilterAzureVnetInfoResourceGroup(val string) AzureVnetInfoFieldFilter {
	return func(tgt *AzureVnetInfo) error {
		return tgt.addResourceGroup(val)
	}
}

// ResourceGroupWasSet allows for checking if ResourceGroup is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *AzureVnetInfo) ResourceGroupWasSet() (bool, bool) {
	prefix := "resourceGroup."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// ResourceGroupIsModifiable defines whether this field is modifiable per the specs.
func (m *AzureVnetInfo) ResourceGroupIsModifiable() bool {
	return false
}

//
// CVInfo
//

// CVInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type CVInfoFieldFilter func(target *CVInfo) error

// NewCVInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewCVInfoFilter(
	fns ...CVInfoFieldFilter,
) (*CVInfo, error) {
	result := &CVInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing CVInfo.
func (m *CVInfo) AddFilters(fns ...CVInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// CVInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type CVInfoFieldUpdate func(target *CVInfo) error

// NewCVInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewCVInfoUpdate(
	fns ...CVInfoFieldUpdate,
) (*CVInfo, error) {
	result := &CVInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing CVInfo.
func (m *CVInfo) AddUpdates(fns ...CVInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *CVInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *CVInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this CVInfo
func (m *CVInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"bootstrapCfg",
			"cvStatusCode",
			"cvStatusDesc",
			"cvStatusRecommendedAction",
			"deviceStatus",
			"haRtTableIds",
			"haRtrId",
			"peerVpcRtTableId",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addBootstrapCfg(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"bootstrapCfg",
	)

	m.BootstrapCfg = val
	return nil
}

// FilterCVInfoBootstrapCfg exists only for type-safety.
// All work is done in addBootstrapCfg(...)
func FilterCVInfoBootstrapCfg(val string) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addBootstrapCfg(val)
	}
}

// BootstrapCfgWasSet allows for checking if BootstrapCfg is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) BootstrapCfgWasSet() (bool, bool) {
	prefix := "bootstrapCfg."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// BootstrapCfgIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) BootstrapCfgIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addCvStatusCode(val CVStatusCode) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvStatusCode",
	)

	m.CvStatusCode = val
	return nil
}

// FilterCVInfoCvStatusCode exists only for type-safety.
// All work is done in addCvStatusCode(...)
func FilterCVInfoCvStatusCode(val CVStatusCode) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addCvStatusCode(val)
	}
}

// CvStatusCodeWasSet allows for checking if CvStatusCode is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) CvStatusCodeWasSet() (bool, bool) {
	prefix := "cvStatusCode."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvStatusCodeIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) CvStatusCodeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addCvStatusDesc(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvStatusDesc",
	)

	m.CvStatusDesc = val
	return nil
}

// FilterCVInfoCvStatusDesc exists only for type-safety.
// All work is done in addCvStatusDesc(...)
func FilterCVInfoCvStatusDesc(val string) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addCvStatusDesc(val)
	}
}

// CvStatusDescWasSet allows for checking if CvStatusDesc is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) CvStatusDescWasSet() (bool, bool) {
	prefix := "cvStatusDesc."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvStatusDescIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) CvStatusDescIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addCvStatusRecommendedAction(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvStatusRecommendedAction",
	)

	m.CvStatusRecommendedAction = val
	return nil
}

// FilterCVInfoCvStatusRecommendedAction exists only for type-safety.
// All work is done in addCvStatusRecommendedAction(...)
func FilterCVInfoCvStatusRecommendedAction(val string) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addCvStatusRecommendedAction(val)
	}
}

// CvStatusRecommendedActionWasSet allows for checking if CvStatusRecommendedAction is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) CvStatusRecommendedActionWasSet() (bool, bool) {
	prefix := "cvStatusRecommendedAction."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvStatusRecommendedActionIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) CvStatusRecommendedActionIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addDeviceStatus(val DeviceStatusCode) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"deviceStatus",
	)

	m.DeviceStatus = val
	return nil
}

// FilterCVInfoDeviceStatus exists only for type-safety.
// All work is done in addDeviceStatus(...)
func FilterCVInfoDeviceStatus(val DeviceStatusCode) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addDeviceStatus(val)
	}
}

// DeviceStatusWasSet allows for checking if DeviceStatus is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) DeviceStatusWasSet() (bool, bool) {
	prefix := "deviceStatus."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DeviceStatusIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) DeviceStatusIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addHaRtTableIds(val *RouteTableIds) error {
	if val == nil {
		return fmt.Errorf("nil value to HaRtTableIds field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("haRtTableIds.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.HaRtTableIds = val
	return nil
}

// FilterCVInfoHaRtTableIds exists only for type-safety.
// All work is done in addHaRtTableIds(...)
func FilterCVInfoHaRtTableIds(val *RouteTableIds) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addHaRtTableIds(val)
	}
}

// HaRtTableIdsWasSet allows for checking if HaRtTableIds is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) HaRtTableIdsWasSet() (bool, bool) {
	prefix := "haRtTableIds."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// HaRtTableIdsIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) HaRtTableIdsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addHaRtrId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"haRtrId",
	)

	m.HaRtrId = val
	return nil
}

// FilterCVInfoHaRtrId exists only for type-safety.
// All work is done in addHaRtrId(...)
func FilterCVInfoHaRtrId(val string) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addHaRtrId(val)
	}
}

// HaRtrIdWasSet allows for checking if HaRtrId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) HaRtrIdWasSet() (bool, bool) {
	prefix := "haRtrId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// HaRtrIdIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) HaRtrIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *CVInfo) addPeerVpcRtTableId(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerVpcRtTableId",
	)

	m.PeerVpcRtTableId = val
	return nil
}

// FilterCVInfoPeerVpcRtTableId exists only for type-safety.
// All work is done in addPeerVpcRtTableId(...)
func FilterCVInfoPeerVpcRtTableId(val []string) CVInfoFieldFilter {
	return func(tgt *CVInfo) error {
		return tgt.addPeerVpcRtTableId(val)
	}
}

// PeerVpcRtTableIdWasSet allows for checking if PeerVpcRtTableId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *CVInfo) PeerVpcRtTableIdWasSet() (bool, bool) {
	prefix := "peerVpcRtTableId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerVpcRtTableIdIsModifiable defines whether this field is modifiable per the specs.
func (m *CVInfo) PeerVpcRtTableIdIsModifiable() bool {
	return false
}

//
// ClosInfo
//

// ClosInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type ClosInfoFieldFilter func(target *ClosInfo) error

// NewClosInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewClosInfoFilter(
	fns ...ClosInfoFieldFilter,
) (*ClosInfo, error) {
	result := &ClosInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing ClosInfo.
func (m *ClosInfo) AddFilters(fns ...ClosInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// ClosInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type ClosInfoFieldUpdate func(target *ClosInfo) error

// NewClosInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewClosInfoUpdate(
	fns ...ClosInfoFieldUpdate,
) (*ClosInfo, error) {
	result := &ClosInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing ClosInfo.
func (m *ClosInfo) AddUpdates(fns ...ClosInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *ClosInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *ClosInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this ClosInfo
func (m *ClosInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"closName",
			"cpType",
			"cvpContainerName",
			"fabric",
			"leafEdgeIgw",
			"leafEdgePeering",
			"leafEncryption",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addClosName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"closName",
	)

	m.ClosName = val
	return nil
}

// FilterClosInfoClosName exists only for type-safety.
// All work is done in addClosName(...)
func FilterClosInfoClosName(val string) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addClosName(val)
	}
}

// ClosNameWasSet allows for checking if ClosName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) ClosNameWasSet() (bool, bool) {
	prefix := "closName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// ClosNameIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) ClosNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addCpType(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cpType",
	)

	m.CpType = val
	return nil
}

// FilterClosInfoCpType exists only for type-safety.
// All work is done in addCpType(...)
func FilterClosInfoCpType(val CloudProviderType) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addCpType(val)
	}
}

// CpTypeWasSet allows for checking if CpType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) CpTypeWasSet() (bool, bool) {
	prefix := "cpType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CpTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) CpTypeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addCvpContainerName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvpContainerName",
	)

	m.CvpContainerName = val
	return nil
}

// FilterClosInfoCvpContainerName exists only for type-safety.
// All work is done in addCvpContainerName(...)
func FilterClosInfoCvpContainerName(val string) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addCvpContainerName(val)
	}
}

// CvpContainerNameWasSet allows for checking if CvpContainerName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) CvpContainerNameWasSet() (bool, bool) {
	prefix := "cvpContainerName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvpContainerNameIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) CvpContainerNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addFabric(val FabricType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"fabric",
	)

	m.Fabric = val
	return nil
}

// FilterClosInfoFabric exists only for type-safety.
// All work is done in addFabric(...)
func FilterClosInfoFabric(val FabricType) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addFabric(val)
	}
}

// FabricWasSet allows for checking if Fabric is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) FabricWasSet() (bool, bool) {
	prefix := "fabric."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FabricIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) FabricIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addLeafEdgeIgw(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"leafEdgeIgw",
	)

	m.LeafEdgeIgw = val
	return nil
}

// FilterClosInfoLeafEdgeIgw exists only for type-safety.
// All work is done in addLeafEdgeIgw(...)
func FilterClosInfoLeafEdgeIgw(val bool) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addLeafEdgeIgw(val)
	}
}

// LeafEdgeIgwWasSet allows for checking if LeafEdgeIgw is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) LeafEdgeIgwWasSet() (bool, bool) {
	prefix := "leafEdgeIgw."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LeafEdgeIgwIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) LeafEdgeIgwIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addLeafEdgePeering(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"leafEdgePeering",
	)

	m.LeafEdgePeering = val
	return nil
}

// FilterClosInfoLeafEdgePeering exists only for type-safety.
// All work is done in addLeafEdgePeering(...)
func FilterClosInfoLeafEdgePeering(val bool) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addLeafEdgePeering(val)
	}
}

// LeafEdgePeeringWasSet allows for checking if LeafEdgePeering is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) LeafEdgePeeringWasSet() (bool, bool) {
	prefix := "leafEdgePeering."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LeafEdgePeeringIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) LeafEdgePeeringIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *ClosInfo) addLeafEncryption(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"leafEncryption",
	)

	m.LeafEncryption = val
	return nil
}

// FilterClosInfoLeafEncryption exists only for type-safety.
// All work is done in addLeafEncryption(...)
func FilterClosInfoLeafEncryption(val bool) ClosInfoFieldFilter {
	return func(tgt *ClosInfo) error {
		return tgt.addLeafEncryption(val)
	}
}

// LeafEncryptionWasSet allows for checking if LeafEncryption is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *ClosInfo) LeafEncryptionWasSet() (bool, bool) {
	prefix := "leafEncryption."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LeafEncryptionIsModifiable defines whether this field is modifiable per the specs.
func (m *ClosInfo) LeafEncryptionIsModifiable() bool {
	return false
}

//
// NetworkInterface
//

// NetworkInterfaceFieldFilter works as a type-safety guarantee for updates vs. filters
type NetworkInterfaceFieldFilter func(target *NetworkInterface) error

// NewNetworkInterfaceFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewNetworkInterfaceFilter(
	fns ...NetworkInterfaceFieldFilter,
) (*NetworkInterface, error) {
	result := &NetworkInterface{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing NetworkInterface.
func (m *NetworkInterface) AddFilters(fns ...NetworkInterfaceFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// NetworkInterfaceFieldUpdate works as a type-safety guarantee for updates vs. filters
type NetworkInterfaceFieldUpdate func(target *NetworkInterface) error

// NewNetworkInterfaceUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewNetworkInterfaceUpdate(
	fns ...NetworkInterfaceFieldUpdate,
) (*NetworkInterface, error) {
	result := &NetworkInterface{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing NetworkInterface.
func (m *NetworkInterface) AddUpdates(fns ...NetworkInterfaceFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *NetworkInterface) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *NetworkInterface) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this NetworkInterface
func (m *NetworkInterface) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"intfId",
			"intfType",
			"name",
			"privateIpAddr",
			"publicIpAddr",
			"securityGroup",
			"subnet",
		},
	}
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addIntfId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"intfId",
	)

	m.IntfId = val
	return nil
}

// FilterNetworkInterfaceIntfId exists only for type-safety.
// All work is done in addIntfId(...)
func FilterNetworkInterfaceIntfId(val string) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addIntfId(val)
	}
}

// IntfIdWasSet allows for checking if IntfId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) IntfIdWasSet() (bool, bool) {
	prefix := "intfId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IntfIdIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) IntfIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addIntfType(val NetworkInterfaceType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"intfType",
	)

	m.IntfType = val
	return nil
}

// FilterNetworkInterfaceIntfType exists only for type-safety.
// All work is done in addIntfType(...)
func FilterNetworkInterfaceIntfType(val NetworkInterfaceType) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addIntfType(val)
	}
}

// IntfTypeWasSet allows for checking if IntfType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) IntfTypeWasSet() (bool, bool) {
	prefix := "intfType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IntfTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) IntfTypeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"name",
	)

	m.Name = val
	return nil
}

// FilterNetworkInterfaceName exists only for type-safety.
// All work is done in addName(...)
func FilterNetworkInterfaceName(val string) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addName(val)
	}
}

// NameWasSet allows for checking if Name is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) NameWasSet() (bool, bool) {
	prefix := "name."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// NameIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) NameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addPrivateIpAddr(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"privateIpAddr",
	)

	m.PrivateIpAddr = val
	return nil
}

// FilterNetworkInterfacePrivateIpAddr exists only for type-safety.
// All work is done in addPrivateIpAddr(...)
func FilterNetworkInterfacePrivateIpAddr(val []string) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addPrivateIpAddr(val)
	}
}

// PrivateIpAddrWasSet allows for checking if PrivateIpAddr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) PrivateIpAddrWasSet() (bool, bool) {
	prefix := "privateIpAddr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PrivateIpAddrIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) PrivateIpAddrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addPublicIpAddr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"publicIpAddr",
	)

	m.PublicIpAddr = val
	return nil
}

// FilterNetworkInterfacePublicIpAddr exists only for type-safety.
// All work is done in addPublicIpAddr(...)
func FilterNetworkInterfacePublicIpAddr(val string) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addPublicIpAddr(val)
	}
}

// PublicIpAddrWasSet allows for checking if PublicIpAddr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) PublicIpAddrWasSet() (bool, bool) {
	prefix := "publicIpAddr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PublicIpAddrIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) PublicIpAddrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addSecurityGroup(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"securityGroup",
	)

	m.SecurityGroup = val
	return nil
}

// FilterNetworkInterfaceSecurityGroup exists only for type-safety.
// All work is done in addSecurityGroup(...)
func FilterNetworkInterfaceSecurityGroup(val string) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addSecurityGroup(val)
	}
}

// SecurityGroupWasSet allows for checking if SecurityGroup is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) SecurityGroupWasSet() (bool, bool) {
	prefix := "securityGroup."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SecurityGroupIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) SecurityGroupIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *NetworkInterface) addSubnet(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"subnet",
	)

	m.Subnet = val
	return nil
}

// FilterNetworkInterfaceSubnet exists only for type-safety.
// All work is done in addSubnet(...)
func FilterNetworkInterfaceSubnet(val string) NetworkInterfaceFieldFilter {
	return func(tgt *NetworkInterface) error {
		return tgt.addSubnet(val)
	}
}

// SubnetWasSet allows for checking if Subnet is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *NetworkInterface) SubnetWasSet() (bool, bool) {
	prefix := "subnet."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SubnetIsModifiable defines whether this field is modifiable per the specs.
func (m *NetworkInterface) SubnetIsModifiable() bool {
	return false
}

//
// Path
//

// PathFieldFilter works as a type-safety guarantee for updates vs. filters
type PathFieldFilter func(target *Path) error

// NewPathFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewPathFilter(
	fns ...PathFieldFilter,
) (*Path, error) {
	result := &Path{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing Path.
func (m *Path) AddFilters(fns ...PathFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// PathFieldUpdate works as a type-safety guarantee for updates vs. filters
type PathFieldUpdate func(target *Path) error

// NewPathUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewPathUpdate(
	fns ...PathFieldUpdate,
) (*Path, error) {
	result := &Path{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing Path.
func (m *Path) AddUpdates(fns ...PathFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *Path) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *Path) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this Path
func (m *Path) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"dstCpT",
			"dstRegion",
			"dstVpcCloudId",
			"dstVpcName",
			"dstVpcUuid",
			"localIntfIpAddr",
			"localRtrCloudId",
			"localRtrName",
			"localRtrUuid",
			"pathChar",
			"remoteIntfIpAddr",
			"remoteRtrCloudId",
			"remoteRtrName",
			"remoteRtrUuid",
			"srcCpT",
			"srcRegion",
			"srcVpcCloudId",
			"srcVpcName",
			"srcVpcUuid",
			"topologyName",
			"ulT",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addDstCpT(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"dstCpT",
	)

	m.DstCpT = val
	return nil
}

// FilterPathDstCpT exists only for type-safety.
// All work is done in addDstCpT(...)
func FilterPathDstCpT(val CloudProviderType) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addDstCpT(val)
	}
}

// DstCpTWasSet allows for checking if DstCpT is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) DstCpTWasSet() (bool, bool) {
	prefix := "dstCpT."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DstCpTIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) DstCpTIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addDstRegion(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"dstRegion",
	)

	m.DstRegion = val
	return nil
}

// FilterPathDstRegion exists only for type-safety.
// All work is done in addDstRegion(...)
func FilterPathDstRegion(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addDstRegion(val)
	}
}

// DstRegionWasSet allows for checking if DstRegion is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) DstRegionWasSet() (bool, bool) {
	prefix := "dstRegion."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DstRegionIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) DstRegionIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addDstVpcCloudId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"dstVpcCloudId",
	)

	m.DstVpcCloudId = val
	return nil
}

// FilterPathDstVpcCloudId exists only for type-safety.
// All work is done in addDstVpcCloudId(...)
func FilterPathDstVpcCloudId(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addDstVpcCloudId(val)
	}
}

// DstVpcCloudIdWasSet allows for checking if DstVpcCloudId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) DstVpcCloudIdWasSet() (bool, bool) {
	prefix := "dstVpcCloudId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DstVpcCloudIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) DstVpcCloudIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addDstVpcName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"dstVpcName",
	)

	m.DstVpcName = val
	return nil
}

// FilterPathDstVpcName exists only for type-safety.
// All work is done in addDstVpcName(...)
func FilterPathDstVpcName(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addDstVpcName(val)
	}
}

// DstVpcNameWasSet allows for checking if DstVpcName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) DstVpcNameWasSet() (bool, bool) {
	prefix := "dstVpcName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DstVpcNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) DstVpcNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addDstVpcUuid(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"dstVpcUuid",
	)

	m.DstVpcUuid = val
	return nil
}

// FilterPathDstVpcUuid exists only for type-safety.
// All work is done in addDstVpcUuid(...)
func FilterPathDstVpcUuid(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addDstVpcUuid(val)
	}
}

// DstVpcUuidWasSet allows for checking if DstVpcUuid is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) DstVpcUuidWasSet() (bool, bool) {
	prefix := "dstVpcUuid."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DstVpcUuidIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) DstVpcUuidIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addLocalIntfIpAddr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"localIntfIpAddr",
	)

	m.LocalIntfIpAddr = val
	return nil
}

// FilterPathLocalIntfIpAddr exists only for type-safety.
// All work is done in addLocalIntfIpAddr(...)
func FilterPathLocalIntfIpAddr(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addLocalIntfIpAddr(val)
	}
}

// LocalIntfIpAddrWasSet allows for checking if LocalIntfIpAddr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) LocalIntfIpAddrWasSet() (bool, bool) {
	prefix := "localIntfIpAddr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LocalIntfIpAddrIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) LocalIntfIpAddrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addLocalRtrCloudId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"localRtrCloudId",
	)

	m.LocalRtrCloudId = val
	return nil
}

// FilterPathLocalRtrCloudId exists only for type-safety.
// All work is done in addLocalRtrCloudId(...)
func FilterPathLocalRtrCloudId(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addLocalRtrCloudId(val)
	}
}

// LocalRtrCloudIdWasSet allows for checking if LocalRtrCloudId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) LocalRtrCloudIdWasSet() (bool, bool) {
	prefix := "localRtrCloudId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LocalRtrCloudIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) LocalRtrCloudIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addLocalRtrName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"localRtrName",
	)

	m.LocalRtrName = val
	return nil
}

// FilterPathLocalRtrName exists only for type-safety.
// All work is done in addLocalRtrName(...)
func FilterPathLocalRtrName(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addLocalRtrName(val)
	}
}

// LocalRtrNameWasSet allows for checking if LocalRtrName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) LocalRtrNameWasSet() (bool, bool) {
	prefix := "localRtrName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LocalRtrNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) LocalRtrNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addLocalRtrUuid(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"localRtrUuid",
	)

	m.LocalRtrUuid = val
	return nil
}

// FilterPathLocalRtrUuid exists only for type-safety.
// All work is done in addLocalRtrUuid(...)
func FilterPathLocalRtrUuid(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addLocalRtrUuid(val)
	}
}

// LocalRtrUuidWasSet allows for checking if LocalRtrUuid is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) LocalRtrUuidWasSet() (bool, bool) {
	prefix := "localRtrUuid."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LocalRtrUuidIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) LocalRtrUuidIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addPathChar(val *PathCharacteristics) error {
	if val == nil {
		return fmt.Errorf("nil value to PathChar field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("pathChar.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.PathChar = val
	return nil
}

// FilterPathPathChar exists only for type-safety.
// All work is done in addPathChar(...)
func FilterPathPathChar(val *PathCharacteristics) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addPathChar(val)
	}
}

// PathCharWasSet allows for checking if PathChar is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) PathCharWasSet() (bool, bool) {
	prefix := "pathChar."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PathCharIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) PathCharIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addRemoteIntfIpAddr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"remoteIntfIpAddr",
	)

	m.RemoteIntfIpAddr = val
	return nil
}

// FilterPathRemoteIntfIpAddr exists only for type-safety.
// All work is done in addRemoteIntfIpAddr(...)
func FilterPathRemoteIntfIpAddr(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addRemoteIntfIpAddr(val)
	}
}

// RemoteIntfIpAddrWasSet allows for checking if RemoteIntfIpAddr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) RemoteIntfIpAddrWasSet() (bool, bool) {
	prefix := "remoteIntfIpAddr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RemoteIntfIpAddrIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) RemoteIntfIpAddrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addRemoteRtrCloudId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"remoteRtrCloudId",
	)

	m.RemoteRtrCloudId = val
	return nil
}

// FilterPathRemoteRtrCloudId exists only for type-safety.
// All work is done in addRemoteRtrCloudId(...)
func FilterPathRemoteRtrCloudId(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addRemoteRtrCloudId(val)
	}
}

// RemoteRtrCloudIdWasSet allows for checking if RemoteRtrCloudId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) RemoteRtrCloudIdWasSet() (bool, bool) {
	prefix := "remoteRtrCloudId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RemoteRtrCloudIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) RemoteRtrCloudIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addRemoteRtrName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"remoteRtrName",
	)

	m.RemoteRtrName = val
	return nil
}

// FilterPathRemoteRtrName exists only for type-safety.
// All work is done in addRemoteRtrName(...)
func FilterPathRemoteRtrName(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addRemoteRtrName(val)
	}
}

// RemoteRtrNameWasSet allows for checking if RemoteRtrName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) RemoteRtrNameWasSet() (bool, bool) {
	prefix := "remoteRtrName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RemoteRtrNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) RemoteRtrNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addRemoteRtrUuid(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"remoteRtrUuid",
	)

	m.RemoteRtrUuid = val
	return nil
}

// FilterPathRemoteRtrUuid exists only for type-safety.
// All work is done in addRemoteRtrUuid(...)
func FilterPathRemoteRtrUuid(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addRemoteRtrUuid(val)
	}
}

// RemoteRtrUuidWasSet allows for checking if RemoteRtrUuid is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) RemoteRtrUuidWasSet() (bool, bool) {
	prefix := "remoteRtrUuid."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RemoteRtrUuidIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) RemoteRtrUuidIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addSrcCpT(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"srcCpT",
	)

	m.SrcCpT = val
	return nil
}

// FilterPathSrcCpT exists only for type-safety.
// All work is done in addSrcCpT(...)
func FilterPathSrcCpT(val CloudProviderType) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addSrcCpT(val)
	}
}

// SrcCpTWasSet allows for checking if SrcCpT is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) SrcCpTWasSet() (bool, bool) {
	prefix := "srcCpT."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SrcCpTIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) SrcCpTIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addSrcRegion(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"srcRegion",
	)

	m.SrcRegion = val
	return nil
}

// FilterPathSrcRegion exists only for type-safety.
// All work is done in addSrcRegion(...)
func FilterPathSrcRegion(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addSrcRegion(val)
	}
}

// SrcRegionWasSet allows for checking if SrcRegion is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) SrcRegionWasSet() (bool, bool) {
	prefix := "srcRegion."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SrcRegionIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) SrcRegionIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addSrcVpcCloudId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"srcVpcCloudId",
	)

	m.SrcVpcCloudId = val
	return nil
}

// FilterPathSrcVpcCloudId exists only for type-safety.
// All work is done in addSrcVpcCloudId(...)
func FilterPathSrcVpcCloudId(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addSrcVpcCloudId(val)
	}
}

// SrcVpcCloudIdWasSet allows for checking if SrcVpcCloudId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) SrcVpcCloudIdWasSet() (bool, bool) {
	prefix := "srcVpcCloudId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SrcVpcCloudIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) SrcVpcCloudIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addSrcVpcName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"srcVpcName",
	)

	m.SrcVpcName = val
	return nil
}

// FilterPathSrcVpcName exists only for type-safety.
// All work is done in addSrcVpcName(...)
func FilterPathSrcVpcName(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addSrcVpcName(val)
	}
}

// SrcVpcNameWasSet allows for checking if SrcVpcName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) SrcVpcNameWasSet() (bool, bool) {
	prefix := "srcVpcName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SrcVpcNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) SrcVpcNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addSrcVpcUuid(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"srcVpcUuid",
	)

	m.SrcVpcUuid = val
	return nil
}

// FilterPathSrcVpcUuid exists only for type-safety.
// All work is done in addSrcVpcUuid(...)
func FilterPathSrcVpcUuid(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addSrcVpcUuid(val)
	}
}

// SrcVpcUuidWasSet allows for checking if SrcVpcUuid is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) SrcVpcUuidWasSet() (bool, bool) {
	prefix := "srcVpcUuid."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SrcVpcUuidIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) SrcVpcUuidIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addTopologyName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"topologyName",
	)

	m.TopologyName = val
	return nil
}

// FilterPathTopologyName exists only for type-safety.
// All work is done in addTopologyName(...)
func FilterPathTopologyName(val string) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addTopologyName(val)
	}
}

// TopologyNameWasSet allows for checking if TopologyName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) TopologyNameWasSet() (bool, bool) {
	prefix := "topologyName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// TopologyNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) TopologyNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Path) addUlT(val UnderlayConnectionType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"ulT",
	)

	m.UlT = val
	return nil
}

// FilterPathUlT exists only for type-safety.
// All work is done in addUlT(...)
func FilterPathUlT(val UnderlayConnectionType) PathFieldFilter {
	return func(tgt *Path) error {
		return tgt.addUlT(val)
	}
}

// UlTWasSet allows for checking if UlT is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Path) UlTWasSet() (bool, bool) {
	prefix := "ulT."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// UlTIsModifiable defines whether this field is modifiable per the specs.
func (m *Path) UlTIsModifiable() bool {
	return false
}

//
// PathCharacteristics
//

// PathCharacteristicsFieldFilter works as a type-safety guarantee for updates vs. filters
type PathCharacteristicsFieldFilter func(target *PathCharacteristics) error

// NewPathCharacteristicsFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewPathCharacteristicsFilter(
	fns ...PathCharacteristicsFieldFilter,
) (*PathCharacteristics, error) {
	result := &PathCharacteristics{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing PathCharacteristics.
func (m *PathCharacteristics) AddFilters(fns ...PathCharacteristicsFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// PathCharacteristicsFieldUpdate works as a type-safety guarantee for updates vs. filters
type PathCharacteristicsFieldUpdate func(target *PathCharacteristics) error

// NewPathCharacteristicsUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewPathCharacteristicsUpdate(
	fns ...PathCharacteristicsFieldUpdate,
) (*PathCharacteristics, error) {
	result := &PathCharacteristics{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing PathCharacteristics.
func (m *PathCharacteristics) AddUpdates(fns ...PathCharacteristicsFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *PathCharacteristics) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *PathCharacteristics) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this PathCharacteristics
func (m *PathCharacteristics) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"bwMbps",
			"jitterMs",
			"latencyMs",
			"pktLossPc",
			"up",
			"uptime",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PathCharacteristics) addBwMbps(val uint64) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"bwMbps",
	)

	m.BwMbps = val
	return nil
}

// FilterPathCharacteristicsBwMbps exists only for type-safety.
// All work is done in addBwMbps(...)
func FilterPathCharacteristicsBwMbps(val uint64) PathCharacteristicsFieldFilter {
	return func(tgt *PathCharacteristics) error {
		return tgt.addBwMbps(val)
	}
}

// BwMbpsWasSet allows for checking if BwMbps is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) BwMbpsWasSet() (bool, bool) {
	prefix := "bwMbps."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// BwMbpsIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) BwMbpsIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PathCharacteristics) addJitterMs(val uint64) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"jitterMs",
	)

	m.JitterMs = val
	return nil
}

// FilterPathCharacteristicsJitterMs exists only for type-safety.
// All work is done in addJitterMs(...)
func FilterPathCharacteristicsJitterMs(val uint64) PathCharacteristicsFieldFilter {
	return func(tgt *PathCharacteristics) error {
		return tgt.addJitterMs(val)
	}
}

// JitterMsWasSet allows for checking if JitterMs is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) JitterMsWasSet() (bool, bool) {
	prefix := "jitterMs."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// JitterMsIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) JitterMsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PathCharacteristics) addLatencyMs(val uint64) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"latencyMs",
	)

	m.LatencyMs = val
	return nil
}

// FilterPathCharacteristicsLatencyMs exists only for type-safety.
// All work is done in addLatencyMs(...)
func FilterPathCharacteristicsLatencyMs(val uint64) PathCharacteristicsFieldFilter {
	return func(tgt *PathCharacteristics) error {
		return tgt.addLatencyMs(val)
	}
}

// LatencyMsWasSet allows for checking if LatencyMs is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) LatencyMsWasSet() (bool, bool) {
	prefix := "latencyMs."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// LatencyMsIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) LatencyMsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PathCharacteristics) addPktLossPc(val uint64) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"pktLossPc",
	)

	m.PktLossPc = val
	return nil
}

// FilterPathCharacteristicsPktLossPc exists only for type-safety.
// All work is done in addPktLossPc(...)
func FilterPathCharacteristicsPktLossPc(val uint64) PathCharacteristicsFieldFilter {
	return func(tgt *PathCharacteristics) error {
		return tgt.addPktLossPc(val)
	}
}

// PktLossPcWasSet allows for checking if PktLossPc is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) PktLossPcWasSet() (bool, bool) {
	prefix := "pktLossPc."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PktLossPcIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) PktLossPcIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PathCharacteristics) addUp(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"up",
	)

	m.Up = val
	return nil
}

// FilterPathCharacteristicsUp exists only for type-safety.
// All work is done in addUp(...)
func FilterPathCharacteristicsUp(val bool) PathCharacteristicsFieldFilter {
	return func(tgt *PathCharacteristics) error {
		return tgt.addUp(val)
	}
}

// UpWasSet allows for checking if Up is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) UpWasSet() (bool, bool) {
	prefix := "up."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// UpIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) UpIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PathCharacteristics) addUptime(val uint64) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"uptime",
	)

	m.Uptime = val
	return nil
}

// FilterPathCharacteristicsUptime exists only for type-safety.
// All work is done in addUptime(...)
func FilterPathCharacteristicsUptime(val uint64) PathCharacteristicsFieldFilter {
	return func(tgt *PathCharacteristics) error {
		return tgt.addUptime(val)
	}
}

// UptimeWasSet allows for checking if Uptime is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PathCharacteristics) UptimeWasSet() (bool, bool) {
	prefix := "uptime."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// UptimeIsModifiable defines whether this field is modifiable per the specs.
func (m *PathCharacteristics) UptimeIsModifiable() bool {
	return false
}

//
// PeerVpcInfo
//

// PeerVpcInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type PeerVpcInfoFieldFilter func(target *PeerVpcInfo) error

// NewPeerVpcInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewPeerVpcInfoFilter(
	fns ...PeerVpcInfoFieldFilter,
) (*PeerVpcInfo, error) {
	result := &PeerVpcInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing PeerVpcInfo.
func (m *PeerVpcInfo) AddFilters(fns ...PeerVpcInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// PeerVpcInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type PeerVpcInfoFieldUpdate func(target *PeerVpcInfo) error

// NewPeerVpcInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewPeerVpcInfoUpdate(
	fns ...PeerVpcInfoFieldUpdate,
) (*PeerVpcInfo, error) {
	result := &PeerVpcInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing PeerVpcInfo.
func (m *PeerVpcInfo) AddUpdates(fns ...PeerVpcInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *PeerVpcInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *PeerVpcInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this PeerVpcInfo
func (m *PeerVpcInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"peerRgName",
			"peerVnetId",
			"peerVnetName",
			"peerVpcCidr",
		},
	}
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PeerVpcInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *PeerVpcInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PeerVpcInfo) addPeerRgName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerRgName",
	)

	m.PeerRgName = val
	return nil
}

// FilterPeerVpcInfoPeerRgName exists only for type-safety.
// All work is done in addPeerRgName(...)
func FilterPeerVpcInfoPeerRgName(val string) PeerVpcInfoFieldFilter {
	return func(tgt *PeerVpcInfo) error {
		return tgt.addPeerRgName(val)
	}
}

// PeerRgNameWasSet allows for checking if PeerRgName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PeerVpcInfo) PeerRgNameWasSet() (bool, bool) {
	prefix := "peerRgName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerRgNameIsModifiable defines whether this field is modifiable per the specs.
func (m *PeerVpcInfo) PeerRgNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PeerVpcInfo) addPeerVnetId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerVnetId",
	)

	m.PeerVnetId = val
	return nil
}

// FilterPeerVpcInfoPeerVnetId exists only for type-safety.
// All work is done in addPeerVnetId(...)
func FilterPeerVpcInfoPeerVnetId(val string) PeerVpcInfoFieldFilter {
	return func(tgt *PeerVpcInfo) error {
		return tgt.addPeerVnetId(val)
	}
}

// PeerVnetIdWasSet allows for checking if PeerVnetId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PeerVpcInfo) PeerVnetIdWasSet() (bool, bool) {
	prefix := "peerVnetId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerVnetIdIsModifiable defines whether this field is modifiable per the specs.
func (m *PeerVpcInfo) PeerVnetIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PeerVpcInfo) addPeerVnetName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerVnetName",
	)

	m.PeerVnetName = val
	return nil
}

// FilterPeerVpcInfoPeerVnetName exists only for type-safety.
// All work is done in addPeerVnetName(...)
func FilterPeerVpcInfoPeerVnetName(val string) PeerVpcInfoFieldFilter {
	return func(tgt *PeerVpcInfo) error {
		return tgt.addPeerVnetName(val)
	}
}

// PeerVnetNameWasSet allows for checking if PeerVnetName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PeerVpcInfo) PeerVnetNameWasSet() (bool, bool) {
	prefix := "peerVnetName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerVnetNameIsModifiable defines whether this field is modifiable per the specs.
func (m *PeerVpcInfo) PeerVnetNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *PeerVpcInfo) addPeerVpcCidr(val map[string]string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerVpcCidr",
	)

	m.PeerVpcCidr = val
	return nil
}

// FilterPeerVpcInfoPeerVpcCidr exists only for type-safety.
// All work is done in addPeerVpcCidr(...)
func FilterPeerVpcInfoPeerVpcCidr(val map[string]string) PeerVpcInfoFieldFilter {
	return func(tgt *PeerVpcInfo) error {
		return tgt.addPeerVpcCidr(val)
	}
}

// PeerVpcCidrWasSet allows for checking if PeerVpcCidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *PeerVpcInfo) PeerVpcCidrWasSet() (bool, bool) {
	prefix := "peerVpcCidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerVpcCidrIsModifiable defines whether this field is modifiable per the specs.
func (m *PeerVpcInfo) PeerVpcCidrIsModifiable() bool {
	return false
}

//
// RouteTableIds
//

// RouteTableIdsFieldFilter works as a type-safety guarantee for updates vs. filters
type RouteTableIdsFieldFilter func(target *RouteTableIds) error

// NewRouteTableIdsFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewRouteTableIdsFilter(
	fns ...RouteTableIdsFieldFilter,
) (*RouteTableIds, error) {
	result := &RouteTableIds{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing RouteTableIds.
func (m *RouteTableIds) AddFilters(fns ...RouteTableIdsFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// RouteTableIdsFieldUpdate works as a type-safety guarantee for updates vs. filters
type RouteTableIdsFieldUpdate func(target *RouteTableIds) error

// NewRouteTableIdsUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewRouteTableIdsUpdate(
	fns ...RouteTableIdsFieldUpdate,
) (*RouteTableIds, error) {
	result := &RouteTableIds{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing RouteTableIds.
func (m *RouteTableIds) AddUpdates(fns ...RouteTableIdsFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *RouteTableIds) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *RouteTableIds) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this RouteTableIds
func (m *RouteTableIds) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"internal",
			"private",
			"public",
		},
	}
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *RouteTableIds) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *RouteTableIds) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *RouteTableIds) addInternal(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"internal",
	)

	m.Internal = val
	return nil
}

// FilterRouteTableIdsInternal exists only for type-safety.
// All work is done in addInternal(...)
func FilterRouteTableIdsInternal(val []string) RouteTableIdsFieldFilter {
	return func(tgt *RouteTableIds) error {
		return tgt.addInternal(val)
	}
}

// InternalWasSet allows for checking if Internal is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *RouteTableIds) InternalWasSet() (bool, bool) {
	prefix := "internal."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// InternalIsModifiable defines whether this field is modifiable per the specs.
func (m *RouteTableIds) InternalIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *RouteTableIds) addPrivate(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"private",
	)

	m.Private = val
	return nil
}

// FilterRouteTableIdsPrivate exists only for type-safety.
// All work is done in addPrivate(...)
func FilterRouteTableIdsPrivate(val []string) RouteTableIdsFieldFilter {
	return func(tgt *RouteTableIds) error {
		return tgt.addPrivate(val)
	}
}

// PrivateWasSet allows for checking if Private is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *RouteTableIds) PrivateWasSet() (bool, bool) {
	prefix := "private."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PrivateIsModifiable defines whether this field is modifiable per the specs.
func (m *RouteTableIds) PrivateIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *RouteTableIds) addPublic(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"public",
	)

	m.Public = val
	return nil
}

// FilterRouteTableIdsPublic exists only for type-safety.
// All work is done in addPublic(...)
func FilterRouteTableIdsPublic(val []string) RouteTableIdsFieldFilter {
	return func(tgt *RouteTableIds) error {
		return tgt.addPublic(val)
	}
}

// PublicWasSet allows for checking if Public is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *RouteTableIds) PublicWasSet() (bool, bool) {
	prefix := "public."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PublicIsModifiable defines whether this field is modifiable per the specs.
func (m *RouteTableIds) PublicIsModifiable() bool {
	return false
}

//
// Router
//

// RouterFieldFilter works as a type-safety guarantee for updates vs. filters
type RouterFieldFilter func(target *Router) error

// NewRouterFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewRouterFilter(
	fns ...RouterFieldFilter,
) (*Router, error) {
	result := &Router{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing Router.
func (m *Router) AddFilters(fns ...RouterFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// RouterFieldUpdate works as a type-safety guarantee for updates vs. filters
type RouterFieldUpdate func(target *Router) error

// NewRouterUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewRouterUpdate(
	fns ...RouterFieldUpdate,
) (*Router, error) {
	result := &Router{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing Router.
func (m *Router) AddUpdates(fns ...RouterFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *Router) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *Router) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this Router
func (m *Router) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"awsRtrDetail",
			"azRtrDetail",
			"cnps",
			"cpT",
			"cvInfo",
			"depStatus",
			"deviceEnrollmentToken",
			"deviceSerialNum",
			"haName",
			"id",
			"instanceId",
			"intf",
			"name",
			"region",
			"routeReflector",
			"rtTableIds",
			"tags",
			"vpcId",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addAwsRtrDetail(val *AwsRouterDetail) error {
	if val == nil {
		return fmt.Errorf("nil value to AwsRtrDetail field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("awsRtrDetail.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.AwsRtrDetail = val
	return nil
}

// FilterRouterAwsRtrDetail exists only for type-safety.
// All work is done in addAwsRtrDetail(...)
func FilterRouterAwsRtrDetail(val *AwsRouterDetail) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addAwsRtrDetail(val)
	}
}

// AwsRtrDetailWasSet allows for checking if AwsRtrDetail is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) AwsRtrDetailWasSet() (bool, bool) {
	prefix := "awsRtrDetail."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AwsRtrDetailIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) AwsRtrDetailIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addAzRtrDetail(val *AzureRouterDetail) error {
	if val == nil {
		return fmt.Errorf("nil value to AzRtrDetail field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("azRtrDetail.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.AzRtrDetail = val
	return nil
}

// FilterRouterAzRtrDetail exists only for type-safety.
// All work is done in addAzRtrDetail(...)
func FilterRouterAzRtrDetail(val *AzureRouterDetail) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addAzRtrDetail(val)
	}
}

// AzRtrDetailWasSet allows for checking if AzRtrDetail is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) AzRtrDetailWasSet() (bool, bool) {
	prefix := "azRtrDetail."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AzRtrDetailIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) AzRtrDetailIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addCnps(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cnps",
	)

	m.Cnps = val
	return nil
}

// FilterRouterCnps exists only for type-safety.
// All work is done in addCnps(...)
func FilterRouterCnps(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addCnps(val)
	}
}

// CnpsWasSet allows for checking if Cnps is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) CnpsWasSet() (bool, bool) {
	prefix := "cnps."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CnpsIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) CnpsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addCpT(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cpT",
	)

	m.CpT = val
	return nil
}

// FilterRouterCpT exists only for type-safety.
// All work is done in addCpT(...)
func FilterRouterCpT(val CloudProviderType) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addCpT(val)
	}
}

// CpTWasSet allows for checking if CpT is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) CpTWasSet() (bool, bool) {
	prefix := "cpT."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CpTIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) CpTIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addCvInfo(val *CVInfo) error {
	if val == nil {
		return fmt.Errorf("nil value to CvInfo field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("cvInfo.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.CvInfo = val
	return nil
}

// FilterRouterCvInfo exists only for type-safety.
// All work is done in addCvInfo(...)
func FilterRouterCvInfo(val *CVInfo) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addCvInfo(val)
	}
}

// CvInfoWasSet allows for checking if CvInfo is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) CvInfoWasSet() (bool, bool) {
	prefix := "cvInfo."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvInfoIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) CvInfoIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addDepStatus(val DeploymentStatusCode) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"depStatus",
	)

	m.DepStatus = val
	return nil
}

// FilterRouterDepStatus exists only for type-safety.
// All work is done in addDepStatus(...)
func FilterRouterDepStatus(val DeploymentStatusCode) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addDepStatus(val)
	}
}

// DepStatusWasSet allows for checking if DepStatus is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) DepStatusWasSet() (bool, bool) {
	prefix := "depStatus."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DepStatusIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) DepStatusIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addDeviceEnrollmentToken(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"deviceEnrollmentToken",
	)

	m.DeviceEnrollmentToken = val
	return nil
}

// FilterRouterDeviceEnrollmentToken exists only for type-safety.
// All work is done in addDeviceEnrollmentToken(...)
func FilterRouterDeviceEnrollmentToken(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addDeviceEnrollmentToken(val)
	}
}

// DeviceEnrollmentTokenWasSet allows for checking if DeviceEnrollmentToken is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) DeviceEnrollmentTokenWasSet() (bool, bool) {
	prefix := "deviceEnrollmentToken."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DeviceEnrollmentTokenIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) DeviceEnrollmentTokenIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addDeviceSerialNum(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"deviceSerialNum",
	)

	m.DeviceSerialNum = val
	return nil
}

// FilterRouterDeviceSerialNum exists only for type-safety.
// All work is done in addDeviceSerialNum(...)
func FilterRouterDeviceSerialNum(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addDeviceSerialNum(val)
	}
}

// DeviceSerialNumWasSet allows for checking if DeviceSerialNum is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) DeviceSerialNumWasSet() (bool, bool) {
	prefix := "deviceSerialNum."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DeviceSerialNumIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) DeviceSerialNumIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addHaName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"haName",
	)

	m.HaName = val
	return nil
}

// FilterRouterHaName exists only for type-safety.
// All work is done in addHaName(...)
func FilterRouterHaName(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addHaName(val)
	}
}

// HaNameWasSet allows for checking if HaName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) HaNameWasSet() (bool, bool) {
	prefix := "haName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// HaNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) HaNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"id",
	)

	m.Id = val
	return nil
}

// FilterRouterId exists only for type-safety.
// All work is done in addId(...)
func FilterRouterId(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addId(val)
	}
}

// IdWasSet allows for checking if Id is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) IdWasSet() (bool, bool) {
	prefix := "id."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IdIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) IdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addInstanceId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"instanceId",
	)

	m.InstanceId = val
	return nil
}

// FilterRouterInstanceId exists only for type-safety.
// All work is done in addInstanceId(...)
func FilterRouterInstanceId(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addInstanceId(val)
	}
}

// InstanceIdWasSet allows for checking if InstanceId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) InstanceIdWasSet() (bool, bool) {
	prefix := "instanceId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// InstanceIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) InstanceIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addIntf(val []*NetworkInterface) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"intf",
	)

	m.Intf = val
	return nil
}

// FilterRouterIntf exists only for type-safety.
// All work is done in addIntf(...)
func FilterRouterIntf(val []*NetworkInterface) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addIntf(val)
	}
}

// IntfWasSet allows for checking if Intf is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) IntfWasSet() (bool, bool) {
	prefix := "intf."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IntfIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) IntfIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"name",
	)

	m.Name = val
	return nil
}

// FilterRouterName exists only for type-safety.
// All work is done in addName(...)
func FilterRouterName(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addName(val)
	}
}

// NameWasSet allows for checking if Name is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) NameWasSet() (bool, bool) {
	prefix := "name."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// NameIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) NameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addRegion(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"region",
	)

	m.Region = val
	return nil
}

// FilterRouterRegion exists only for type-safety.
// All work is done in addRegion(...)
func FilterRouterRegion(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addRegion(val)
	}
}

// RegionWasSet allows for checking if Region is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) RegionWasSet() (bool, bool) {
	prefix := "region."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RegionIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) RegionIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addRouteReflector(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"routeReflector",
	)

	m.RouteReflector = val
	return nil
}

// FilterRouterRouteReflector exists only for type-safety.
// All work is done in addRouteReflector(...)
func FilterRouterRouteReflector(val bool) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addRouteReflector(val)
	}
}

// RouteReflectorWasSet allows for checking if RouteReflector is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) RouteReflectorWasSet() (bool, bool) {
	prefix := "routeReflector."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RouteReflectorIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) RouteReflectorIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addRtTableIds(val *RouteTableIds) error {
	if val == nil {
		return fmt.Errorf("nil value to RtTableIds field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("rtTableIds.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.RtTableIds = val
	return nil
}

// FilterRouterRtTableIds exists only for type-safety.
// All work is done in addRtTableIds(...)
func FilterRouterRtTableIds(val *RouteTableIds) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addRtTableIds(val)
	}
}

// RtTableIdsWasSet allows for checking if RtTableIds is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) RtTableIdsWasSet() (bool, bool) {
	prefix := "rtTableIds."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RtTableIdsIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) RtTableIdsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addTags(val map[string]string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"tags",
	)

	m.Tags = val
	return nil
}

// FilterRouterTags exists only for type-safety.
// All work is done in addTags(...)
func FilterRouterTags(val map[string]string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addTags(val)
	}
}

// TagsWasSet allows for checking if Tags is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) TagsWasSet() (bool, bool) {
	prefix := "tags."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// TagsIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) TagsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Router) addVpcId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"vpcId",
	)

	m.VpcId = val
	return nil
}

// FilterRouterVpcId exists only for type-safety.
// All work is done in addVpcId(...)
func FilterRouterVpcId(val string) RouterFieldFilter {
	return func(tgt *Router) error {
		return tgt.addVpcId(val)
	}
}

// VpcIdWasSet allows for checking if VpcId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Router) VpcIdWasSet() (bool, bool) {
	prefix := "vpcId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// VpcIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Router) VpcIdIsModifiable() bool {
	return false
}

//
// Subnet
//

// SubnetFieldFilter works as a type-safety guarantee for updates vs. filters
type SubnetFieldFilter func(target *Subnet) error

// NewSubnetFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewSubnetFilter(
	fns ...SubnetFieldFilter,
) (*Subnet, error) {
	result := &Subnet{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing Subnet.
func (m *Subnet) AddFilters(fns ...SubnetFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// SubnetFieldUpdate works as a type-safety guarantee for updates vs. filters
type SubnetFieldUpdate func(target *Subnet) error

// NewSubnetUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewSubnetUpdate(
	fns ...SubnetFieldUpdate,
) (*Subnet, error) {
	result := &Subnet{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing Subnet.
func (m *Subnet) AddUpdates(fns ...SubnetFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *Subnet) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *Subnet) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this Subnet
func (m *Subnet) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"availZone",
			"cidr",
			"cpT",
			"id",
			"primGw",
			"secGw",
			"subnetId",
			"vpcId",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addAvailZone(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"availZone",
	)

	m.AvailZone = val
	return nil
}

// FilterSubnetAvailZone exists only for type-safety.
// All work is done in addAvailZone(...)
func FilterSubnetAvailZone(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addAvailZone(val)
	}
}

// AvailZoneWasSet allows for checking if AvailZone is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) AvailZoneWasSet() (bool, bool) {
	prefix := "availZone."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AvailZoneIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) AvailZoneIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addCidr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cidr",
	)

	m.Cidr = val
	return nil
}

// FilterSubnetCidr exists only for type-safety.
// All work is done in addCidr(...)
func FilterSubnetCidr(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addCidr(val)
	}
}

// CidrWasSet allows for checking if Cidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) CidrWasSet() (bool, bool) {
	prefix := "cidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CidrIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) CidrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addCpT(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cpT",
	)

	m.CpT = val
	return nil
}

// FilterSubnetCpT exists only for type-safety.
// All work is done in addCpT(...)
func FilterSubnetCpT(val CloudProviderType) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addCpT(val)
	}
}

// CpTWasSet allows for checking if CpT is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) CpTWasSet() (bool, bool) {
	prefix := "cpT."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CpTIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) CpTIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"id",
	)

	m.Id = val
	return nil
}

// FilterSubnetId exists only for type-safety.
// All work is done in addId(...)
func FilterSubnetId(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addId(val)
	}
}

// IdWasSet allows for checking if Id is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) IdWasSet() (bool, bool) {
	prefix := "id."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IdIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) IdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addPrimGw(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"primGw",
	)

	m.PrimGw = val
	return nil
}

// FilterSubnetPrimGw exists only for type-safety.
// All work is done in addPrimGw(...)
func FilterSubnetPrimGw(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addPrimGw(val)
	}
}

// PrimGwWasSet allows for checking if PrimGw is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) PrimGwWasSet() (bool, bool) {
	prefix := "primGw."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PrimGwIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) PrimGwIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addSecGw(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"secGw",
	)

	m.SecGw = val
	return nil
}

// FilterSubnetSecGw exists only for type-safety.
// All work is done in addSecGw(...)
func FilterSubnetSecGw(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addSecGw(val)
	}
}

// SecGwWasSet allows for checking if SecGw is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) SecGwWasSet() (bool, bool) {
	prefix := "secGw."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SecGwIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) SecGwIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addSubnetId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"subnetId",
	)

	m.SubnetId = val
	return nil
}

// FilterSubnetSubnetId exists only for type-safety.
// All work is done in addSubnetId(...)
func FilterSubnetSubnetId(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addSubnetId(val)
	}
}

// SubnetIdWasSet allows for checking if SubnetId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) SubnetIdWasSet() (bool, bool) {
	prefix := "subnetId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// SubnetIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) SubnetIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Subnet) addVpcId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"vpcId",
	)

	m.VpcId = val
	return nil
}

// FilterSubnetVpcId exists only for type-safety.
// All work is done in addVpcId(...)
func FilterSubnetVpcId(val string) SubnetFieldFilter {
	return func(tgt *Subnet) error {
		return tgt.addVpcId(val)
	}
}

// VpcIdWasSet allows for checking if VpcId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Subnet) VpcIdWasSet() (bool, bool) {
	prefix := "vpcId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// VpcIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Subnet) VpcIdIsModifiable() bool {
	return false
}

//
// TopologyInfo
//

// TopologyInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type TopologyInfoFieldFilter func(target *TopologyInfo) error

// NewTopologyInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewTopologyInfoFilter(
	fns ...TopologyInfoFieldFilter,
) (*TopologyInfo, error) {
	result := &TopologyInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing TopologyInfo.
func (m *TopologyInfo) AddFilters(fns ...TopologyInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// TopologyInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type TopologyInfoFieldUpdate func(target *TopologyInfo) error

// NewTopologyInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewTopologyInfoUpdate(
	fns ...TopologyInfoFieldUpdate,
) (*TopologyInfo, error) {
	result := &TopologyInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing TopologyInfo.
func (m *TopologyInfo) AddUpdates(fns ...TopologyInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *TopologyInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *TopologyInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this TopologyInfo
func (m *TopologyInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"bgpAsnHigh",
			"bgpAsnLow",
			"closInfo",
			"cvaasDomain",
			"cvaasServer",
			"dpsControlPlaneCidr",
			"id",
			"managedDevices",
			"name",
			"terminattrIpCidr",
			"topoType",
			"version",
			"vtepIpCidr",
			"wanInfo",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addBgpAsnHigh(val uint32) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"bgpAsnHigh",
	)

	m.BgpAsnHigh = val
	return nil
}

// FilterTopologyInfoBgpAsnHigh exists only for type-safety.
// All work is done in addBgpAsnHigh(...)
func FilterTopologyInfoBgpAsnHigh(val uint32) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addBgpAsnHigh(val)
	}
}

// BgpAsnHighWasSet allows for checking if BgpAsnHigh is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) BgpAsnHighWasSet() (bool, bool) {
	prefix := "bgpAsnHigh."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// BgpAsnHighIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) BgpAsnHighIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addBgpAsnLow(val uint32) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"bgpAsnLow",
	)

	m.BgpAsnLow = val
	return nil
}

// FilterTopologyInfoBgpAsnLow exists only for type-safety.
// All work is done in addBgpAsnLow(...)
func FilterTopologyInfoBgpAsnLow(val uint32) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addBgpAsnLow(val)
	}
}

// BgpAsnLowWasSet allows for checking if BgpAsnLow is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) BgpAsnLowWasSet() (bool, bool) {
	prefix := "bgpAsnLow."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// BgpAsnLowIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) BgpAsnLowIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addClosInfo(val *ClosInfo) error {
	if val == nil {
		return fmt.Errorf("nil value to ClosInfo field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("closInfo.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.ClosInfo = val
	return nil
}

// FilterTopologyInfoClosInfo exists only for type-safety.
// All work is done in addClosInfo(...)
func FilterTopologyInfoClosInfo(val *ClosInfo) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addClosInfo(val)
	}
}

// ClosInfoWasSet allows for checking if ClosInfo is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) ClosInfoWasSet() (bool, bool) {
	prefix := "closInfo."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// ClosInfoIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) ClosInfoIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addCvaasDomain(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvaasDomain",
	)

	m.CvaasDomain = val
	return nil
}

// FilterTopologyInfoCvaasDomain exists only for type-safety.
// All work is done in addCvaasDomain(...)
func FilterTopologyInfoCvaasDomain(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addCvaasDomain(val)
	}
}

// CvaasDomainWasSet allows for checking if CvaasDomain is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) CvaasDomainWasSet() (bool, bool) {
	prefix := "cvaasDomain."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvaasDomainIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) CvaasDomainIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addCvaasServer(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvaasServer",
	)

	m.CvaasServer = val
	return nil
}

// FilterTopologyInfoCvaasServer exists only for type-safety.
// All work is done in addCvaasServer(...)
func FilterTopologyInfoCvaasServer(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addCvaasServer(val)
	}
}

// CvaasServerWasSet allows for checking if CvaasServer is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) CvaasServerWasSet() (bool, bool) {
	prefix := "cvaasServer."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvaasServerIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) CvaasServerIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addDpsControlPlaneCidr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"dpsControlPlaneCidr",
	)

	m.DpsControlPlaneCidr = val
	return nil
}

// FilterTopologyInfoDpsControlPlaneCidr exists only for type-safety.
// All work is done in addDpsControlPlaneCidr(...)
func FilterTopologyInfoDpsControlPlaneCidr(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addDpsControlPlaneCidr(val)
	}
}

// DpsControlPlaneCidrWasSet allows for checking if DpsControlPlaneCidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) DpsControlPlaneCidrWasSet() (bool, bool) {
	prefix := "dpsControlPlaneCidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// DpsControlPlaneCidrIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) DpsControlPlaneCidrIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"id",
	)

	m.Id = val
	return nil
}

// FilterTopologyInfoId exists only for type-safety.
// All work is done in addId(...)
func FilterTopologyInfoId(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addId(val)
	}
}

// IdWasSet allows for checking if Id is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) IdWasSet() (bool, bool) {
	prefix := "id."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IdIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) IdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addManagedDevices(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"managedDevices",
	)

	m.ManagedDevices = val
	return nil
}

// FilterTopologyInfoManagedDevices exists only for type-safety.
// All work is done in addManagedDevices(...)
func FilterTopologyInfoManagedDevices(val []string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addManagedDevices(val)
	}
}

// ManagedDevicesWasSet allows for checking if ManagedDevices is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) ManagedDevicesWasSet() (bool, bool) {
	prefix := "managedDevices."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// ManagedDevicesIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) ManagedDevicesIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"name",
	)

	m.Name = val
	return nil
}

// FilterTopologyInfoName exists only for type-safety.
// All work is done in addName(...)
func FilterTopologyInfoName(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addName(val)
	}
}

// NameWasSet allows for checking if Name is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) NameWasSet() (bool, bool) {
	prefix := "name."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// NameIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) NameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addTerminattrIpCidr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"terminattrIpCidr",
	)

	m.TerminattrIpCidr = val
	return nil
}

// FilterTopologyInfoTerminattrIpCidr exists only for type-safety.
// All work is done in addTerminattrIpCidr(...)
func FilterTopologyInfoTerminattrIpCidr(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addTerminattrIpCidr(val)
	}
}

// TerminattrIpCidrWasSet allows for checking if TerminattrIpCidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) TerminattrIpCidrWasSet() (bool, bool) {
	prefix := "terminattrIpCidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// TerminattrIpCidrIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) TerminattrIpCidrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addTopoType(val TopologyInfoType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"topoType",
	)

	m.TopoType = val
	return nil
}

// FilterTopologyInfoTopoType exists only for type-safety.
// All work is done in addTopoType(...)
func FilterTopologyInfoTopoType(val TopologyInfoType) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addTopoType(val)
	}
}

// TopoTypeWasSet allows for checking if TopoType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) TopoTypeWasSet() (bool, bool) {
	prefix := "topoType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// TopoTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) TopoTypeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addVersion(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"version",
	)

	m.Version = val
	return nil
}

// FilterTopologyInfoVersion exists only for type-safety.
// All work is done in addVersion(...)
func FilterTopologyInfoVersion(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addVersion(val)
	}
}

// VersionWasSet allows for checking if Version is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) VersionWasSet() (bool, bool) {
	prefix := "version."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// VersionIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) VersionIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addVtepIpCidr(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"vtepIpCidr",
	)

	m.VtepIpCidr = val
	return nil
}

// FilterTopologyInfoVtepIpCidr exists only for type-safety.
// All work is done in addVtepIpCidr(...)
func FilterTopologyInfoVtepIpCidr(val string) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addVtepIpCidr(val)
	}
}

// VtepIpCidrWasSet allows for checking if VtepIpCidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) VtepIpCidrWasSet() (bool, bool) {
	prefix := "vtepIpCidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// VtepIpCidrIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) VtepIpCidrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *TopologyInfo) addWanInfo(val *WanInfo) error {
	if val == nil {
		return fmt.Errorf("nil value to WanInfo field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("wanInfo.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.WanInfo = val
	return nil
}

// FilterTopologyInfoWanInfo exists only for type-safety.
// All work is done in addWanInfo(...)
func FilterTopologyInfoWanInfo(val *WanInfo) TopologyInfoFieldFilter {
	return func(tgt *TopologyInfo) error {
		return tgt.addWanInfo(val)
	}
}

// WanInfoWasSet allows for checking if WanInfo is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *TopologyInfo) WanInfoWasSet() (bool, bool) {
	prefix := "wanInfo."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// WanInfoIsModifiable defines whether this field is modifiable per the specs.
func (m *TopologyInfo) WanInfoIsModifiable() bool {
	return false
}

//
// Vpc
//

// VpcFieldFilter works as a type-safety guarantee for updates vs. filters
type VpcFieldFilter func(target *Vpc) error

// NewVpcFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewVpcFilter(
	fns ...VpcFieldFilter,
) (*Vpc, error) {
	result := &Vpc{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing Vpc.
func (m *Vpc) AddFilters(fns ...VpcFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// VpcFieldUpdate works as a type-safety guarantee for updates vs. filters
type VpcFieldUpdate func(target *Vpc) error

// NewVpcUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewVpcUpdate(
	fns ...VpcFieldUpdate,
) (*Vpc, error) {
	result := &Vpc{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing Vpc.
func (m *Vpc) AddUpdates(fns ...VpcFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *Vpc) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *Vpc) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this Vpc
func (m *Vpc) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"account",
			"awsVpcInfo",
			"azVnetInfo",
			"closName",
			"cnps",
			"cpT",
			"id",
			"name",
			"peerVpcCidr",
			"peerVpcInfo",
			"region",
			"roleType",
			"routeReflector",
			"statusCode",
			"tags",
			"topologyName",
			"vpcId",
			"wanName",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addAccount(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"account",
	)

	m.Account = val
	return nil
}

// FilterVpcAccount exists only for type-safety.
// All work is done in addAccount(...)
func FilterVpcAccount(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addAccount(val)
	}
}

// AccountWasSet allows for checking if Account is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) AccountWasSet() (bool, bool) {
	prefix := "account."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AccountIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) AccountIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addAwsVpcInfo(val *AwsVpcInfo) error {
	if val == nil {
		return fmt.Errorf("nil value to AwsVpcInfo field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("awsVpcInfo.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.AwsVpcInfo = val
	return nil
}

// FilterVpcAwsVpcInfo exists only for type-safety.
// All work is done in addAwsVpcInfo(...)
func FilterVpcAwsVpcInfo(val *AwsVpcInfo) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addAwsVpcInfo(val)
	}
}

// AwsVpcInfoWasSet allows for checking if AwsVpcInfo is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) AwsVpcInfoWasSet() (bool, bool) {
	prefix := "awsVpcInfo."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AwsVpcInfoIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) AwsVpcInfoIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addAzVnetInfo(val *AzureVnetInfo) error {
	if val == nil {
		return fmt.Errorf("nil value to AzVnetInfo field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("azVnetInfo.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.AzVnetInfo = val
	return nil
}

// FilterVpcAzVnetInfo exists only for type-safety.
// All work is done in addAzVnetInfo(...)
func FilterVpcAzVnetInfo(val *AzureVnetInfo) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addAzVnetInfo(val)
	}
}

// AzVnetInfoWasSet allows for checking if AzVnetInfo is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) AzVnetInfoWasSet() (bool, bool) {
	prefix := "azVnetInfo."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// AzVnetInfoIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) AzVnetInfoIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addClosName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"closName",
	)

	m.ClosName = val
	return nil
}

// FilterVpcClosName exists only for type-safety.
// All work is done in addClosName(...)
func FilterVpcClosName(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addClosName(val)
	}
}

// ClosNameWasSet allows for checking if ClosName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) ClosNameWasSet() (bool, bool) {
	prefix := "closName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// ClosNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) ClosNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addCnps(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cnps",
	)

	m.Cnps = val
	return nil
}

// FilterVpcCnps exists only for type-safety.
// All work is done in addCnps(...)
func FilterVpcCnps(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addCnps(val)
	}
}

// CnpsWasSet allows for checking if Cnps is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) CnpsWasSet() (bool, bool) {
	prefix := "cnps."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CnpsIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) CnpsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addCpT(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cpT",
	)

	m.CpT = val
	return nil
}

// FilterVpcCpT exists only for type-safety.
// All work is done in addCpT(...)
func FilterVpcCpT(val CloudProviderType) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addCpT(val)
	}
}

// CpTWasSet allows for checking if CpT is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) CpTWasSet() (bool, bool) {
	prefix := "cpT."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CpTIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) CpTIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"id",
	)

	m.Id = val
	return nil
}

// FilterVpcId exists only for type-safety.
// All work is done in addId(...)
func FilterVpcId(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addId(val)
	}
}

// IdWasSet allows for checking if Id is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) IdWasSet() (bool, bool) {
	prefix := "id."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// IdIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) IdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"name",
	)

	m.Name = val
	return nil
}

// FilterVpcName exists only for type-safety.
// All work is done in addName(...)
func FilterVpcName(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addName(val)
	}
}

// NameWasSet allows for checking if Name is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) NameWasSet() (bool, bool) {
	prefix := "name."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// NameIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) NameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addPeerVpcCidr(val map[string]string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerVpcCidr",
	)

	m.PeerVpcCidr = val
	return nil
}

// FilterVpcPeerVpcCidr exists only for type-safety.
// All work is done in addPeerVpcCidr(...)
func FilterVpcPeerVpcCidr(val map[string]string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addPeerVpcCidr(val)
	}
}

// PeerVpcCidrWasSet allows for checking if PeerVpcCidr is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) PeerVpcCidrWasSet() (bool, bool) {
	prefix := "peerVpcCidr."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerVpcCidrIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) PeerVpcCidrIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addPeerVpcInfo(val *PeerVpcInfo) error {
	if val == nil {
		return fmt.Errorf("nil value to PeerVpcInfo field-setter not allowed")
	}
	// validate the incoming field mask
	if val.FieldMask == nil || len(val.FieldMask.Paths) == 0 {
		return fmt.Errorf("nil or empty FieldMask in input")
	}
	// move the nested message's field mask to the outer member
	for _, p := range val.FieldMask.Paths {
		m.FieldMask.Paths = append(
			m.FieldMask.Paths,
			// prefix the new field name
			fmt.Sprintf("peerVpcInfo.%s", p),
		)
	}
	// reset the inner field mask
	val.FieldMask.Reset()

	m.PeerVpcInfo = val
	return nil
}

// FilterVpcPeerVpcInfo exists only for type-safety.
// All work is done in addPeerVpcInfo(...)
func FilterVpcPeerVpcInfo(val *PeerVpcInfo) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addPeerVpcInfo(val)
	}
}

// PeerVpcInfoWasSet allows for checking if PeerVpcInfo is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) PeerVpcInfoWasSet() (bool, bool) {
	prefix := "peerVpcInfo."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerVpcInfoIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) PeerVpcInfoIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addRegion(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"region",
	)

	m.Region = val
	return nil
}

// FilterVpcRegion exists only for type-safety.
// All work is done in addRegion(...)
func FilterVpcRegion(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addRegion(val)
	}
}

// RegionWasSet allows for checking if Region is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) RegionWasSet() (bool, bool) {
	prefix := "region."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RegionIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) RegionIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addRoleType(val RoleType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"roleType",
	)

	m.RoleType = val
	return nil
}

// FilterVpcRoleType exists only for type-safety.
// All work is done in addRoleType(...)
func FilterVpcRoleType(val RoleType) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addRoleType(val)
	}
}

// RoleTypeWasSet allows for checking if RoleType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) RoleTypeWasSet() (bool, bool) {
	prefix := "roleType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RoleTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) RoleTypeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addRouteReflector(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"routeReflector",
	)

	m.RouteReflector = val
	return nil
}

// FilterVpcRouteReflector exists only for type-safety.
// All work is done in addRouteReflector(...)
func FilterVpcRouteReflector(val bool) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addRouteReflector(val)
	}
}

// RouteReflectorWasSet allows for checking if RouteReflector is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) RouteReflectorWasSet() (bool, bool) {
	prefix := "routeReflector."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// RouteReflectorIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) RouteReflectorIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addStatusCode(val VpcStatusCode) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"statusCode",
	)

	m.StatusCode = val
	return nil
}

// FilterVpcStatusCode exists only for type-safety.
// All work is done in addStatusCode(...)
func FilterVpcStatusCode(val VpcStatusCode) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addStatusCode(val)
	}
}

// StatusCodeWasSet allows for checking if StatusCode is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) StatusCodeWasSet() (bool, bool) {
	prefix := "statusCode."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// StatusCodeIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) StatusCodeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addTags(val map[string]string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"tags",
	)

	m.Tags = val
	return nil
}

// FilterVpcTags exists only for type-safety.
// All work is done in addTags(...)
func FilterVpcTags(val map[string]string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addTags(val)
	}
}

// TagsWasSet allows for checking if Tags is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) TagsWasSet() (bool, bool) {
	prefix := "tags."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// TagsIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) TagsIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addTopologyName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"topologyName",
	)

	m.TopologyName = val
	return nil
}

// FilterVpcTopologyName exists only for type-safety.
// All work is done in addTopologyName(...)
func FilterVpcTopologyName(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addTopologyName(val)
	}
}

// TopologyNameWasSet allows for checking if TopologyName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) TopologyNameWasSet() (bool, bool) {
	prefix := "topologyName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// TopologyNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) TopologyNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addVpcId(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"vpcId",
	)

	m.VpcId = val
	return nil
}

// FilterVpcVpcId exists only for type-safety.
// All work is done in addVpcId(...)
func FilterVpcVpcId(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addVpcId(val)
	}
}

// VpcIdWasSet allows for checking if VpcId is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) VpcIdWasSet() (bool, bool) {
	prefix := "vpcId."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// VpcIdIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) VpcIdIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *Vpc) addWanName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"wanName",
	)

	m.WanName = val
	return nil
}

// FilterVpcWanName exists only for type-safety.
// All work is done in addWanName(...)
func FilterVpcWanName(val string) VpcFieldFilter {
	return func(tgt *Vpc) error {
		return tgt.addWanName(val)
	}
}

// WanNameWasSet allows for checking if WanName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *Vpc) WanNameWasSet() (bool, bool) {
	prefix := "wanName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// WanNameIsModifiable defines whether this field is modifiable per the specs.
func (m *Vpc) WanNameIsModifiable() bool {
	return false
}

//
// WanInfo
//

// WanInfoFieldFilter works as a type-safety guarantee for updates vs. filters
type WanInfoFieldFilter func(target *WanInfo) error

// NewWanInfoFilter takes a list of Filter functions to set fields
// and adds them to the contained FieldMask.
func NewWanInfoFilter(
	fns ...WanInfoFieldFilter,
) (*WanInfo, error) {
	result := &WanInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddFilters allows for adding Filter setter-functions to an existing WanInfo.
func (m *WanInfo) AddFilters(fns ...WanInfoFieldFilter) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// WanInfoFieldUpdate works as a type-safety guarantee for updates vs. filters
type WanInfoFieldUpdate func(target *WanInfo) error

// NewWanInfoUpdate takes a list of Update functions to set fields
// and adds them to the contained FieldMask.
func NewWanInfoUpdate(
	fns ...WanInfoFieldUpdate,
) (*WanInfo, error) {
	result := &WanInfo{
		FieldMask: &field_mask.FieldMask{
			Paths: make([]string, 0),
		},
	}
	for _, f := range fns {
		if err := f(result); err != nil {
			return nil, err
		}
	}
	return result, nil
}

// AddUpdates allows for adding Update setter-functions to an existing WanInfo.
func (m *WanInfo) AddUpdates(fns ...WanInfoFieldUpdate) error {
	for _, f := range fns {
		err := f(m)
		if err != nil {
			return err
		}
	}
	return nil
}

// GetFilters returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask but are not modifiable.
func (m *WanInfo) GetFilters() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if !modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// GetUpdates returns a map of the GolangCamelCase field names to inteface{} of the
// fields that were included with the FieldMask and are modifiable, thus, updates
func (m *WanInfo) GetUpdates() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	err := protobuf.FieldMaskForEach(m.FieldMask, m,
		func(name string, val interface{}, modifiable bool) error {
			if modifiable {
				result[name] = val
			}
			return nil
		},
	)

	return result, err
}

// SetFullFieldMask adds all fields (including nested messages) as masked in the
// FieldMask contained on this WanInfo
func (m *WanInfo) SetFullFieldMask() {
	m.FieldMask = &field_mask.FieldMask{
		Paths: []string{
			"cpType",
			"cvpContainerName",
			"edgeDedicatedConnect",
			"edgeEdgeIgw",
			"edgeEdgePeering",
			"peerNames",
			"wanName",
		},
	}
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addCpType(val CloudProviderType) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cpType",
	)

	m.CpType = val
	return nil
}

// FilterWanInfoCpType exists only for type-safety.
// All work is done in addCpType(...)
func FilterWanInfoCpType(val CloudProviderType) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addCpType(val)
	}
}

// CpTypeWasSet allows for checking if CpType is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) CpTypeWasSet() (bool, bool) {
	prefix := "cpType."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CpTypeIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) CpTypeIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addCvpContainerName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"cvpContainerName",
	)

	m.CvpContainerName = val
	return nil
}

// FilterWanInfoCvpContainerName exists only for type-safety.
// All work is done in addCvpContainerName(...)
func FilterWanInfoCvpContainerName(val string) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addCvpContainerName(val)
	}
}

// CvpContainerNameWasSet allows for checking if CvpContainerName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) CvpContainerNameWasSet() (bool, bool) {
	prefix := "cvpContainerName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// CvpContainerNameIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) CvpContainerNameIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addEdgeDedicatedConnect(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"edgeDedicatedConnect",
	)

	m.EdgeDedicatedConnect = val
	return nil
}

// FilterWanInfoEdgeDedicatedConnect exists only for type-safety.
// All work is done in addEdgeDedicatedConnect(...)
func FilterWanInfoEdgeDedicatedConnect(val bool) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addEdgeDedicatedConnect(val)
	}
}

// EdgeDedicatedConnectWasSet allows for checking if EdgeDedicatedConnect is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) EdgeDedicatedConnectWasSet() (bool, bool) {
	prefix := "edgeDedicatedConnect."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// EdgeDedicatedConnectIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) EdgeDedicatedConnectIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addEdgeEdgeIgw(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"edgeEdgeIgw",
	)

	m.EdgeEdgeIgw = val
	return nil
}

// FilterWanInfoEdgeEdgeIgw exists only for type-safety.
// All work is done in addEdgeEdgeIgw(...)
func FilterWanInfoEdgeEdgeIgw(val bool) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addEdgeEdgeIgw(val)
	}
}

// EdgeEdgeIgwWasSet allows for checking if EdgeEdgeIgw is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) EdgeEdgeIgwWasSet() (bool, bool) {
	prefix := "edgeEdgeIgw."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// EdgeEdgeIgwIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) EdgeEdgeIgwIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addEdgeEdgePeering(val bool) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"edgeEdgePeering",
	)

	m.EdgeEdgePeering = val
	return nil
}

// FilterWanInfoEdgeEdgePeering exists only for type-safety.
// All work is done in addEdgeEdgePeering(...)
func FilterWanInfoEdgeEdgePeering(val bool) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addEdgeEdgePeering(val)
	}
}

// EdgeEdgePeeringWasSet allows for checking if EdgeEdgePeering is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) EdgeEdgePeeringWasSet() (bool, bool) {
	prefix := "edgeEdgePeering."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// EdgeEdgePeeringIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) EdgeEdgePeeringIsModifiable() bool {
	return false
}

// FieldMaskWasSet allows for checking if FieldMask is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) FieldMaskWasSet() (bool, bool) {
	prefix := "fieldMask."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// FieldMaskIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) FieldMaskIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addPeerNames(val []string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"peerNames",
	)

	m.PeerNames = val
	return nil
}

// FilterWanInfoPeerNames exists only for type-safety.
// All work is done in addPeerNames(...)
func FilterWanInfoPeerNames(val []string) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addPeerNames(val)
	}
}

// PeerNamesWasSet allows for checking if PeerNames is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) PeerNamesWasSet() (bool, bool) {
	prefix := "peerNames."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// PeerNamesIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) PeerNamesIsModifiable() bool {
	return false
}

// Adds a field mask and sets the value with no safety.
// The lack of safety is why it is unexported
func (m *WanInfo) addWanName(val string) error {
	// add the field to mask
	m.FieldMask.Paths = append(
		m.FieldMask.Paths,
		"wanName",
	)

	m.WanName = val
	return nil
}

// FilterWanInfoWanName exists only for type-safety.
// All work is done in addWanName(...)
func FilterWanInfoWanName(val string) WanInfoFieldFilter {
	return func(tgt *WanInfo) error {
		return tgt.addWanName(val)
	}
}

// WanNameWasSet allows for checking if WanName is in the FieldMask.
//
// The return is whether there was a field (including nested resources/fields) followed
// by whether it was an exact match. Simple types will always return the same boolean value
// in both return values. Only structured/nested fields may return non-equal booleans.
// There cannot, however, be (false, true) as this defies the contract here.
func (m *WanInfo) WanNameWasSet() (bool, bool) {
	prefix := "wanName."
	for _, p := range m.FieldMask.Paths {
		// if we have exactly this field, we're done -- but trim the period
		if p == prefix[0:len(prefix)-1] {
			return true, true
		}

		// have a child
		if strings.HasPrefix(p, prefix) {
			return true, false
		}
	}
	return false, false
}

// WanNameIsModifiable defines whether this field is modifiable per the specs.
func (m *WanInfo) WanNameIsModifiable() bool {
	return false
}
